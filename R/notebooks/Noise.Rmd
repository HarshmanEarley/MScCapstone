---
title: "Noise Removal"
output: html_notebook
---

```{r}
source("~/Documents/DAC_Project/R/Noise.R")
```


```{r}
source("~/Documents/DAC_Project/R/Noise.R")
D_51 =  read_csv(getFilePath("train_data"), col_select = "D_51", show_col_types = FALSE) %>% pull()
```

```{r}
round(1/78,5)
```

```{r}
0.0128205
0.0000001

fractions(round(1/78,7))
```

```{r}
vec = D_51
```

```{r}
 nums = c()
  i = 1
  nums[1] = min(vec)
  max_vec = max(vec)
  
  #While below max value, find min value in chunks of 0.01
  while(max_vec > (last(nums) + 0.01)){
    #print(last(nums))
    boundMin = ifelse(i == 1, min(vec), min(vec[!vec <= (nums[i-1]+ 0.01)]))
    bound = vec[between(vec, boundMin, boundMin + 0.01)]
    #nums[i] = median(bound) - 0.005
    #if(nums[i] < 0){nums[i] = 0}
    nums[i] = min(bound)
    i = i+1
  }
  
  #Get GCD of two middle sequential values, take that to be our interval to nearest rational 
  intervals = c()
  for(k in 1:(length(nums)-1)){
    inter =  nums[k+1] - nums[k] 
    
    numDenom =  as.numeric(str_split(as.character(fractions(inter,  max.denominator = 100)), "/", simplify = TRUE))
    
    if(length(numDenom) == 1){
      intervals[k] = 1
      next
    }
    
    intervals[k] = (numDenom[1]/numDenom[2])
    #print(numDenom[1]/numDenom[2])
    #invs = ccpwrap_gdcFloat( nums[k], nums[k+1])
    #Test to see if all values are multiples of the interval, to 0.000000000000001 precision (one place less than test case)
    #validation = all((nums %%  medInterval) < (0.0000001))
    #intervals[k] = ifelse(TRUE, invs, NA)
  }
  
  #median(intervals)
  tableInter = table(intervals)
  as.numeric(names(tableInter[which(tableInter == max(tableInter))]))
```

```{r}
as.character(as.numeric(fractions(1.33333)))
```

```{r}
numDenom = as.numeric(str_split(as.character(fractions(0.33333)), "/", simplify = TRUE))

numDenom[1]/numDenom[2]
```


```{r}
1.66666 - 1.33333
```

```{r}
ccpwrap_gdcFloat(1.66666,1.33333)
```

```{r}
as.character(nums[k])
as.character(nums[k-1])
```


```{r}
k = 6
 ccpwrap_gdcFloat( nums[k], nums[k+1])
```

```{r}
hist(D_51, xlim = c(0.32,0.35), breaks = 1000000)
```

```{r}
getInterval(D_51)
```


```{r}
#cols = c('B_4', 'B_16', 'B_20','B_22','B_30')

cols = c('B_41', 'D_39', 'D_44','D_49','D_51')
cols_N = length(cols)
resultsDF = data.frame(cols = cols, interval = numeric(cols_N))
for(i in 1:cols_N){
  print(i)
  resultsDF[i,2] = getInterval_loadData("train_data", cols[i])
}
```

```{r}
1/71
3076/218071     
```

```{r}
fractions(resultsDF$interval)
```

```{r}
vec = read_csv(getFilePath("train_data"), col_select = 'D_49', show_col_types = FALSE) %>% pull()
  vec = na.omit(vec)
```

```{r}
vec[between(vec,10.5,10.8)]
```


```{r}
c(10.79491, 10.79528, 10.79498, 10.79652) %% (1/71)
```

```{r}
hist(vec[vec > 2], breaks = 100000000, xlim = c(10.795,10.8))
```

```{r}
hist(vec, breaks = 1000000)
```

```{r}
intervals
```

```{r}
 nums = c()
  i = 1
  nums[1] = min(vec)
  max_vec = max(vec)
  
  #While below max value, find min value in chunks of 0.01
  while(max_vec > (last(nums) + 0.01)){
    #print(last(nums))
    boundMin = ifelse(i == 1, min(vec), min(vec[!vec <= (nums[i-1]+ 0.01)]))
    bound = vec[between(vec, boundMin, boundMin + 0.01)]
    #nums[i] = median(bound) - 0.005
    #if(nums[i] < 0){nums[i] = 0}
    nums[i] = min(bound)
    i = i+1
  }
  
  #Get GCD of two middle sequential values, take that to be our interval to nearest rational 
  intervals = c()
  for(k in 1:(length(nums)-1)){
    inter =  nums[k+1] - nums[k] 
    
    numDenom =  as.numeric(str_split(as.character(fractions(inter,  max.denominator = 100)), "/", simplify = TRUE))
    
    if(length(numDenom) == 1){
      intervals[k] = 1
      next
    }
    
    intervals[k] = (numDenom[1]/numDenom[2])
    print(numDenom[1]/numDenom[2])
    #invs = ccpwrap_gdcFloat( nums[k], nums[k+1])
    #Test to see if all values are multiples of the interval, to 0.000000000000001 precision (one place less than test case)
    #validation = all((nums %%  medInterval) < (0.0000001))
    #intervals[k] = ifelse(TRUE, invs, NA)
  }
  
  table(intervals)
```

```{r}
table(intervals)[which(table(intervals) > 1)]
```

```{r}
tableInter = table(intervals)
tableInter[which(tableInter == max(tableInter))]
```


```{r}
fractions(0.0140845070422535)
```

```{r}
k = 1
inter = nums[k+1] - nums[k] 
as.numeric(str_split(as.character(fractions(inter,  max.denominator = 100)), "/", simplify = TRUE))
```


