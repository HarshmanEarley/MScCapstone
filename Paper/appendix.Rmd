# Appendices

## Appendix A: additional tables

```{r,  echo=FALSE, caption}
# load result vectors
results <- as.data.frame(readRDS("results.rds"))
colnames(results) <- c("Model","Measure","Value")
kable(results, caption = "Test data results")
```
\newpage

## Appendix B: additional figures

Insert content for additional figures here.

\newpage

## Appendix C: code

```{r, eval=FALSE}

amex_metric = function(target, pred){
  
  df = data.frame(target, pred)
    # Default rate captured at 4%
    top_four_percent_captured = function(target, pred){
    df = data.frame(target, pred)
    # Descending predictions (pred == 1 first)
    df = df  %>% arrange(-pred)
    # define weight (negative labels are given a weight of 20 to adjust for down sampling)
    df[,'weight'] = ifelse(df[,'target'] == 0, 20, 1)
    # get rows under 4% cutoff
    pctCut = as.integer(sum(0.04*df[,'weight']))
    pctCut = df[cumsum(df[,'weight']) <= pctCut,]
    # return
    sum(pctCut['target'] == 1)/sum(df['target'] == 1)
  }
  
  weighted_gini = function(target, pred){
    df = data.frame(target, pred)
    df = df  %>% arrange(-pred)
    # define weight (negative labels are given a weight of 20 to adjust for down sampling)
    df[,'weight'] = ifelse(df[,'target'] == 0, 20, 1)
    df[,'random'] = cumsum(df[,'weight'] / sum(df[,'weight']))
    total_pos = sum(df[,'target'] * df[,'weight'])
    df[,'cum_pos_found'] = cumsum(df[,'target'] * df[,'weight'])
    #Define lorentz and Gini variables
    df[,'lorentz'] = df[,'cum_pos_found'] / total_pos
    df[,'gini'] = df[,'weight'] * (df[,'lorentz'] - df[,'random'])
    # return
    sum(df[,'gini'])
  }
  
  normalized_weighted_gini = function(target, pred){
    weighted_gini(target, pred) / weighted_gini(target, target)
  }
  
  G = normalized_weighted_gini(target, pred)
  D = top_four_percent_captured(target, pred)
  
  # Return val
  0.5 * (G + D)
  
}
```


```{r, eval=FALSE}

pred_full <- readRDS("pred_full.rds")
# completely right - all rows in agreement 1 or 0
sum(rowSums(pred_full) == 5 | rowSums(pred_full) == 0 )/nrow(pred_full)

# completely wrong - four predictions opposite to observed
comp_wrong1 <-(pred_full[,1] == 0) & (rowSums(pred_full[,c(2,3,4,5)]) == 4) 
comp_wrong2 <-(pred_full[,1] == 1) & (rowSums(pred_full[,c(2,3,4,5)]) == 0)

(as.numeric(summary(comp_wrong1)[3])+as.numeric(summary(comp_wrong2)[3]))/nrow(pred_full)

# majority vote - 2 vs vote for default
maj <- ifelse(rowSums(pred_full[,c(2,3,4,5)]) < 2, 0, 1)

table(maj, pred_full[,1])
#sensitivity specificity and accuracy
tabfunc <- function(pred, obs){
  tab <-table(obs, pred)
  acc <- sum(diag(tab))/sum(tab)
  sens <- tab[2,2]/sum(tab[2,c(1,2)])
  spec <- tab[1,1]/sum(tab[1,c(1,2)])
  return(c(sens, spec, acc))
}
# sens, spec and acc
tabfunc(maj,pred_full[,1])
```



Insert code (if any) used during your dissertation work here.