---
title: "Noise Removal"
output: html_notebook
---

```{r, warning = FALSE}
source("~/Documents/DAC_Project/R/config.R")
source("~/Documents/DAC_Project/R/cleansing_v2.R")
source("~/Documents/DAC_Project/R/Noise.R")


```
```{r}
round(0.1234567,6)
```

```{r}
all(replicate(1000,0.005 == round(mean(runif(5500000, 0, 0.01)),5)))
```


```{r}
source("~/Documents/DAC_Project/R/config.R")
```


```{r}
?replicate
```


```{r}
B_4 = read_csv(getFilePath("train_data"), col_select = 'B_4', show_col_types = FALSE) %>% pull()

```



```{r}
0.005 == round(mean(B_4 %% (1/78)),5)
```

```{r}
ks.test(Values, "punif", min(Values), max(Values))
```


```{r}
B_4 = na.omit(B_4)
```


```{r}
max(B_4)
min(B_4)
```

```{r}

ks.test(bound,"punif",min(bound),min(bound) + 0.01)$p > 0.05

```


```{r}
ks.test(B_4,"punif",min(B_4),min(B_4) + 0.01)
```


```{r}
  nums = c()
  i = 1
  nums[1] = min(vec)
  max_vec = max(vec)
  
  #While below max value, find min value in chunks of 0.01
  while(max_vec > (last(nums) + 0.01)){
    boundMin = ifelse(i == 1, min(vec), min(vec[!vec <= (nums[i-1]+ 0.01)]))
    bound = vec[between(vec, boundMin, boundMin + 0.01)]
    nums[i] = min(bound)
    i = i+1
  }
  
  #Get GCD of two middle sequential values, take that to be our interval to nearest rational 
  intervals = c()
  for(k in 1:(length(nums)-1)){
    inter =  nums[k+1] - nums[k] 
    
    numDenom =  as.numeric(str_split(as.character(fractions(inter,  max.denominator = 100)), "/", simplify = TRUE))
    
    if(length(numDenom) == 1){
      intervals[k] = numDenom
      next
    }
    
    intervals[k] = (numDenom[1]/numDenom[2])
    #invs = ccpwrap_gdcFloat( nums[k], nums[k+1])
    #Test to see if all values are multiples of the interval, to 0.000000000000001 precision (one place less than test case)
    #validation = all((nums %%  medInterval) < (0.0000001))
    #intervals[k] = ifelse(TRUE, invs, NA)
  }
  
  #median(intervals)
  tableInter = table(intervals)
  candidate = as.numeric(names(tableInter[which(tableInter == max(tableInter))]))
  
  if(!length(candidate) == 1){ #Return NA if we cannot reach a consensus
    return(NA)
  }
  
  #modulo remainder iid uniform (0,0.1) by assumption, thus first moment mu_hat = 0.005
  if(!0.005 == round(mean(vec %% candidate),5)){
    return(NA)
  }
  
  #Use Kolmogorov-Smirnov test to check bound is uniform(l, l + 0.01) 
  #If we reject H0: bound comes from unif dist, return NA
  if(ks.test(vec %% candidate,"punif",0, 0.01)$p < 0.05){
      return(NA)
    }
  
  return(candidate)
```



```{r}
getFilePath("Noise", ".R", checkDBOnly = FALSE)
```

```{r}
cols = c(
  'D_68',
  'D_70',
  'D_72',
  'D_74',
  'D_75',
  'D_78',
  'D_79',
  'D_80',
  'D_81'
)

  intervals = list()
 cachePath = glue(PATH_DB,"cache/","intervals")
  cols_N = length(cols)
  
  #Return if we got em all.
  if(cols_N == 0){
    return(1)
  }
  
  #Else calc missing intervals 
  for(i in 1:cols_N){
    print(glue("getting interval for ",cols[i]))
    intervals[[cols[i]]] = getInterval_loadData("train_data", cols[i])
    save(intervals, file = cachePath)
  }

```


```{r}
x['D_68'] = floorify_frac(x['D_68'])
x['D_70'] = floorify_frac(x['D_70'],1/4)
x['D_72'] = floorify_frac(x['D_72'],1/3)
x['D_74'] = floorify_frac(x['D_74'],1/14)
x['D_75'] = floorify_frac(x['D_75'],1/15)
x['D_78'] = floorify_frac(x['D_78'],1/2)
x['D_79'] = floorify_frac(x['D_79'],1/2)
x['D_80'] = floorify_frac(x['D_80'],1/5)
x['D_81'] = floorify_frac(x['D_81'])
```

